{"version":3,"file":"spriteManager.js","sourceRoot":"","sources":["../../../sourceES6/core/Sprites/spriteManager.ts"],"names":[],"mappings":"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","sourcesContent":["import { IDisposable, Scene } from \"../scene\";\r\nimport { Nullable } from \"../types\";\r\nimport { Observable, Observer } from \"../Misc/observable\";\r\nimport { Buffer } from \"../Meshes/buffer\";\r\nimport { VertexBuffer } from \"../Meshes/buffer\";\r\nimport { Vector3, TmpVectors } from \"../Maths/math.vector\";\r\nimport { Sprite } from \"./sprite\";\r\nimport { SpriteSceneComponent } from \"./spriteSceneComponent\";\r\nimport { PickingInfo } from \"../Collisions/pickingInfo\";\r\nimport { Camera } from \"../Cameras/camera\";\r\nimport { Texture } from \"../Materials/Textures/texture\";\r\nimport { Effect } from \"../Materials/effect\";\r\nimport { Material } from \"../Materials/material\";\r\nimport { SceneComponentConstants } from \"../sceneComponent\";\r\n\r\nimport { Logger } from \"../Misc/logger\";\r\n\r\nimport \"../Shaders/sprites.fragment\";\r\nimport \"../Shaders/sprites.vertex\";\r\nimport { DataBuffer } from '../Meshes/dataBuffer';\r\ndeclare type Ray = import(\"../Culling/ray\").Ray;\r\n\r\n/**\r\n * Defines the minimum interface to fullfil in order to be a sprite manager.\r\n */\r\nexport interface ISpriteManager extends IDisposable {\r\n    /**\r\n     * Restricts the camera to viewing objects with the same layerMask.\r\n     * A camera with a layerMask of 1 will render spriteManager.layerMask & camera.layerMask!== 0\r\n     */\r\n    layerMask: number;\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating if the mesh can be picked (by scene.pick for instance or through actions). Default is true\r\n     */\r\n    isPickable: boolean;\r\n\r\n    /**\r\n     * Specifies the rendering group id for this mesh (0 by default)\r\n     * @see http://doc.babylonjs.com/resources/transparency_and_how_meshes_are_rendered#rendering-groups\r\n     */\r\n    renderingGroupId: number;\r\n\r\n    /**\r\n     * Defines the list of sprites managed by the manager.\r\n     */\r\n    sprites: Array<Sprite>;\r\n\r\n    /**\r\n     * Tests the intersection of a sprite with a specific ray.\r\n     * @param ray The ray we are sending to test the collision\r\n     * @param camera The camera space we are sending rays in\r\n     * @param predicate A predicate allowing excluding sprites from the list of object to test\r\n     * @param fastCheck Is the hit test done in a OOBB or AOBB fashion the faster, the less precise\r\n     * @returns picking info or null.\r\n     */\r\n    intersects(ray: Ray, camera: Camera, predicate?: (sprite: Sprite) => boolean, fastCheck?: boolean): Nullable<PickingInfo>;\r\n\r\n    /**\r\n     * Intersects the sprites with a ray\r\n     * @param ray defines the ray to intersect with\r\n     * @param camera defines the current active camera\r\n     * @param predicate defines a predicate used to select candidate sprites\r\n     * @returns null if no hit or a PickingInfo array\r\n     */\r\n    multiIntersects(ray: Ray, camera: Camera, predicate?: (sprite: Sprite) => boolean): Nullable<PickingInfo[]>;\r\n\r\n    /**\r\n     * Renders the list of sprites on screen.\r\n     */\r\n    render(): void;\r\n}\r\n\r\n/**\r\n * Class used to manage multiple sprites on the same spritesheet\r\n * @see http://doc.babylonjs.com/babylon101/sprites\r\n */\r\nexport class SpriteManager implements ISpriteManager {\r\n    /** Gets the list of sprites */\r\n    public sprites = new Array<Sprite>();\r\n    /** Gets or sets the rendering group id (0 by default) */\r\n    public renderingGroupId = 0;\r\n    /** Gets or sets camera layer mask */\r\n    public layerMask: number = 0x0FFFFFFF;\r\n    /** Gets or sets a boolean indicating if the manager must consider scene fog when rendering */\r\n    public fogEnabled = true;\r\n    /** Gets or sets a boolean indicating if the sprites are pickable */\r\n    public isPickable = false;\r\n    /** Defines the default width of a cell in the spritesheet */\r\n    public cellWidth: number;\r\n    /** Defines the default height of a cell in the spritesheet */\r\n    public cellHeight: number;\r\n\r\n    /** Associative array from JSON sprite data file */\r\n    private _cellData: any;\r\n    /** Array of sprite names from JSON sprite data file */\r\n    private _spriteMap: Array<string>;\r\n    /** True when packed cell data from JSON file is ready*/\r\n    private _packedAndReady: boolean = false;\r\n\r\n    /**\r\n    * An event triggered when the manager is disposed.\r\n    */\r\n    public onDisposeObservable = new Observable<SpriteManager>();\r\n\r\n    private _onDisposeObserver: Nullable<Observer<SpriteManager>>;\r\n\r\n    /**\r\n     * Callback called when the manager is disposed\r\n     */\r\n    public set onDispose(callback: () => void) {\r\n        if (this._onDisposeObserver) {\r\n            this.onDisposeObservable.remove(this._onDisposeObserver);\r\n        }\r\n        this._onDisposeObserver = this.onDisposeObservable.add(callback);\r\n    }\r\n\r\n    private _capacity: number;\r\n    private _fromPacked: boolean;\r\n    private _spriteTexture: Texture;\r\n    private _epsilon: number;\r\n\r\n    private _scene: Scene;\r\n\r\n    private _vertexData: Float32Array;\r\n    private _buffer: Buffer;\r\n    private _vertexBuffers: { [key: string]: VertexBuffer } = {};\r\n    private _indexBuffer: DataBuffer;\r\n    private _effectBase: Effect;\r\n    private _effectFog: Effect;\r\n\r\n    /**\r\n     * Gets or sets the spritesheet texture\r\n     */\r\n    public get texture(): Texture {\r\n        return this._spriteTexture;\r\n    }\r\n\r\n    public set texture(value: Texture) {\r\n        this._spriteTexture = value;\r\n    }\r\n\r\n    private _blendMode = 2;\r\n    /**\r\n     * Blend mode use to render the particle, it can be any of\r\n     * the static undefined properties provided in this class.\r\n     * Default value is 2\r\n     */\r\n    public get blendMode() { return this._blendMode; }\r\n    public set blendMode(blendMode: number) {\r\n        this._blendMode = blendMode;\r\n    }\r\n\r\n    /** Disables writing to the depth buffer when rendering the sprites.\r\n     *  It can be handy to disable depth writing when using textures without alpha channel\r\n     *  and setting some specific blend modes.\r\n    */\r\n    public disableDepthWrite: boolean = false;\r\n\r\n    /**\r\n     * Creates a new sprite manager\r\n     * @param name defines the manager's name\r\n     * @param imgUrl defines the sprite sheet url\r\n     * @param capacity defines the maximum allowed number of sprites\r\n     * @param cellSize defines the size of a sprite cell\r\n     * @param scene defines the hosting scene\r\n     * @param epsilon defines the epsilon value to align texture (0.01 by default)\r\n     * @param samplingMode defines the smapling mode to use with spritesheet\r\n     * @param fromPacked set to false; do not alter\r\n     * @param spriteJSON null otherwise a JSON object defining sprite sheet data; do not alter\r\n     */\r\n    constructor(\r\n        /** defines the manager's name */\r\n        public name: string,\r\n        imgUrl: string, capacity: number, cellSize: any, scene: Scene, epsilon: number = 0.01, samplingMode: number = Texture.TRILINEAR_SAMPLINGMODE, fromPacked: boolean = false, spriteJSON: any | null = null) {\r\n        if (!scene._getComponent(SceneComponentConstants.NAME_SPRITE)) {\r\n            scene._addComponent(new SpriteSceneComponent(scene));\r\n        }\r\n        this._capacity = capacity;\r\n        this._fromPacked = fromPacked;\r\n        this._spriteTexture = new Texture(imgUrl, scene, true, false, samplingMode);\r\n        this._spriteTexture.wrapU = Texture.CLAMP_ADDRESSMODE;\r\n        this._spriteTexture.wrapV = Texture.CLAMP_ADDRESSMODE;\r\n\r\n        if (cellSize.width && cellSize.height) {\r\n            this.cellWidth = cellSize.width;\r\n            this.cellHeight = cellSize.height;\r\n        } else if (cellSize !== undefined) {\r\n            this.cellWidth = cellSize;\r\n            this.cellHeight = cellSize;\r\n        } else {\r\n            return;\r\n        }\r\n\r\n        this._epsilon = epsilon;\r\n        this._scene = scene;\r\n        this._scene.spriteManagers.push(this);\r\n\r\n        var indices = [];\r\n        var index = 0;\r\n        for (var count = 0; count < capacity; count++) {\r\n            indices.push(index);\r\n            indices.push(index + 1);\r\n            indices.push(index + 2);\r\n            indices.push(index);\r\n            indices.push(index + 2);\r\n            indices.push(index + 3);\r\n            index += 4;\r\n        }\r\n\r\n        this._indexBuffer = scene.getEngine().createIndexBuffer(indices);\r\n\r\n        // VBO\r\n        // 18 floats per sprite (x, y, z, angle, sizeX, sizeY, offsetX, offsetY, invertU, invertV, cellLeft, cellTop, cellWidth, cellHeight, color r, color g, color b, color a)\r\n        this._vertexData = new Float32Array(capacity * 18 * 4);\r\n        this._buffer = new Buffer(scene.getEngine(), this._vertexData, true, 18);\r\n\r\n        var positions = this._buffer.createVertexBuffer(VertexBuffer.PositionKind, 0, 4);\r\n        var options = this._buffer.createVertexBuffer(\"options\", 4, 4);\r\n        var inverts = this._buffer.createVertexBuffer(\"inverts\", 8, 2);\r\n        var cellInfo = this._buffer.createVertexBuffer(\"cellInfo\", 10, 4);\r\n        var colors = this._buffer.createVertexBuffer(VertexBuffer.ColorKind, 14, 4);\r\n\r\n        this._vertexBuffers[VertexBuffer.PositionKind] = positions;\r\n        this._vertexBuffers[\"options\"] = options;\r\n        this._vertexBuffers[\"inverts\"] = inverts;\r\n        this._vertexBuffers[\"cellInfo\"] = cellInfo;\r\n        this._vertexBuffers[VertexBuffer.ColorKind] = colors;\r\n\r\n        // Effects\r\n        this._effectBase = this._scene.getEngine().createEffect(\"sprites\",\r\n            [VertexBuffer.PositionKind, \"options\", \"inverts\", \"cellInfo\", VertexBuffer.ColorKind],\r\n            [\"view\", \"projection\", \"textureInfos\", \"alphaTest\"],\r\n            [\"diffuseSampler\"], \"\");\r\n\r\n        this._effectFog = this._scene.getEngine().createEffect(\"sprites\",\r\n            [VertexBuffer.PositionKind, \"options\", \"inverts\", \"cellInfo\", VertexBuffer.ColorKind],\r\n            [\"view\", \"projection\", \"textureInfos\", \"alphaTest\", \"vFogInfos\", \"vFogColor\"],\r\n            [\"diffuseSampler\"], \"#define FOG\");\r\n\r\n        if (this._fromPacked) {\r\n            this._makePacked(imgUrl, spriteJSON);\r\n        }\r\n    }\r\n\r\n    private _makePacked(imgUrl: string, spriteJSON: any) {\r\n        if (spriteJSON !== null) {\r\n            try {\r\n                //Get the JSON and Check its stucture.  If its an array parse it if its a JSON sring etc...\r\n                let celldata: any;\r\n                if (typeof spriteJSON === \"string\") {\r\n                    celldata = JSON.parse(spriteJSON);\r\n                }else {\r\n                    celldata = spriteJSON;\r\n                }\r\n\r\n                if (celldata.frames.length) {\r\n                    let frametemp: any = {};\r\n                    for (let i = 0; i < celldata.frames.length; i++) {\r\n                        let _f = celldata.frames[i];\r\n                        if (typeof (Object.keys(_f))[0] !== \"string\") {\r\n                            throw new Error(\"Invalid JSON Format.  Check the frame values and make sure the name is the first parameter.\");\r\n                        }\r\n\r\n                        let name: string = _f[(Object.keys(_f))[0]];\r\n                        frametemp[name] = _f;\r\n                    }\r\n                    celldata.frames = frametemp;\r\n                }\r\n\r\n                let spritemap = (<string[]>(<any>Reflect).ownKeys(celldata.frames));\r\n\r\n                this._spriteMap = spritemap;\r\n                this._packedAndReady = true;\r\n                this._cellData = celldata.frames;\r\n            }\r\n            catch (e) {\r\n                this._fromPacked = false;\r\n                this._packedAndReady = false;\r\n                throw new Error(\"Invalid JSON from string. Spritesheet managed with constant cell size.\");\r\n            }\r\n        }\r\n        else {\r\n            let re = /\\./g;\r\n            let li: number;\r\n            do {\r\n                li = re.lastIndex;\r\n                re.test(imgUrl);\r\n            } while (re.lastIndex > 0);\r\n            let jsonUrl = imgUrl.substring(0, li - 1) + \".json\";\r\n            let xmlhttp = new XMLHttpRequest();\r\n            xmlhttp.open(\"GET\", jsonUrl, true);\r\n            xmlhttp.onerror = () => {\r\n                Logger.Error(\"JSON ERROR: Unable to load JSON file.\");\r\n                this._fromPacked = false;\r\n                this._packedAndReady = false;\r\n            };\r\n            xmlhttp.onload = () => {\r\n                try {\r\n                    let celldata  = JSON.parse(xmlhttp.response);\r\n                    let spritemap = (<string[]>(<any>Reflect).ownKeys(celldata.frames));\r\n                    this._spriteMap = spritemap;\r\n                    this._packedAndReady = true;\r\n                    this._cellData = celldata.frames;\r\n                }\r\n                catch (e) {\r\n                    this._fromPacked = false;\r\n                    this._packedAndReady = false;\r\n                    throw new Error(\"Invalid JSON format. Please check documentation for format specifications.\");\r\n                }\r\n            };\r\n            xmlhttp.send();\r\n        }\r\n    }\r\n\r\n    private _appendSpriteVertex(index: number, sprite: Sprite, offsetX: number, offsetY: number, baseSize: any): void {\r\n        var arrayOffset = index * 18;\r\n\r\n        if (offsetX === 0) {\r\n            offsetX = this._epsilon;\r\n        }\r\n        else if (offsetX === 1) {\r\n            offsetX = 1 - this._epsilon;\r\n        }\r\n\r\n        if (offsetY === 0) {\r\n            offsetY = this._epsilon;\r\n        }\r\n        else if (offsetY === 1) {\r\n            offsetY = 1 - this._epsilon;\r\n        }\r\n\r\n        // Positions\r\n        this._vertexData[arrayOffset] = sprite.position.x;\r\n        this._vertexData[arrayOffset + 1] = sprite.position.y;\r\n        this._vertexData[arrayOffset + 2] = sprite.position.z;\r\n        this._vertexData[arrayOffset + 3] = sprite.angle;\r\n        // Options\r\n        this._vertexData[arrayOffset + 4] = sprite.width;\r\n        this._vertexData[arrayOffset + 5] = sprite.height;\r\n        this._vertexData[arrayOffset + 6] = offsetX;\r\n        this._vertexData[arrayOffset + 7] = offsetY;\r\n        // Inverts\r\n        this._vertexData[arrayOffset + 8] = sprite.invertU ? 1 : 0;\r\n        this._vertexData[arrayOffset + 9] = sprite.invertV ? 1 : 0;\r\n        // CellIfo\r\n        if (this._packedAndReady) {\r\n            if (!sprite.cellRef) {\r\n                sprite.cellIndex = 0;\r\n            }\r\n            let num = sprite.cellIndex;\r\n            if (typeof (num) === \"number\" && isFinite(num) && Math.floor(num) === num) {\r\n                sprite.cellRef = this._spriteMap[sprite.cellIndex];\r\n            }\r\n            this._vertexData[arrayOffset + 10] = this._cellData[sprite.cellRef].frame.x / baseSize.width;\r\n            this._vertexData[arrayOffset + 11] = this._cellData[sprite.cellRef].frame.y / baseSize.height;\r\n            this._vertexData[arrayOffset + 12] = this._cellData[sprite.cellRef].frame.w / baseSize.width;\r\n            this._vertexData[arrayOffset + 13] = this._cellData[sprite.cellRef].frame.h / baseSize.height;\r\n        }\r\n        else {\r\n            if (!sprite.cellIndex) {\r\n                sprite.cellIndex = 0;\r\n            }\r\n            var rowSize = baseSize.width / this.cellWidth;\r\n            var offset = (sprite.cellIndex / rowSize) >> 0;\r\n            this._vertexData[arrayOffset + 10] = (sprite.cellIndex - offset * rowSize) * this.cellWidth / baseSize.width;\r\n            this._vertexData[arrayOffset + 11] = offset * this.cellHeight / baseSize.height;\r\n            this._vertexData[arrayOffset + 12] = this.cellWidth / baseSize.width;\r\n            this._vertexData[arrayOffset + 13] = this.cellHeight / baseSize.height;\r\n        }\r\n        // Color\r\n        this._vertexData[arrayOffset + 14] = sprite.color.r;\r\n        this._vertexData[arrayOffset + 15] = sprite.color.g;\r\n        this._vertexData[arrayOffset + 16] = sprite.color.b;\r\n        this._vertexData[arrayOffset + 17] = sprite.color.a;\r\n    }\r\n\r\n    /**\r\n     * Intersects the sprites with a ray\r\n     * @param ray defines the ray to intersect with\r\n     * @param camera defines the current active camera\r\n     * @param predicate defines a predicate used to select candidate sprites\r\n     * @param fastCheck defines if a fast check only must be done (the first potential sprite is will be used and not the closer)\r\n     * @returns null if no hit or a PickingInfo\r\n     */\r\n    public intersects(ray: Ray, camera: Camera, predicate?: (sprite: Sprite) => boolean, fastCheck?: boolean): Nullable<PickingInfo> {\r\n        var count = Math.min(this._capacity, this.sprites.length);\r\n        var min = Vector3.Zero();\r\n        var max = Vector3.Zero();\r\n        var distance = Number.MAX_VALUE;\r\n        var currentSprite: Nullable<Sprite> = null;\r\n        var pickedPoint = TmpVectors.Vector3[0];\r\n        var cameraSpacePosition = TmpVectors.Vector3[1];\r\n        var cameraView = camera.getViewMatrix();\r\n\r\n        for (var index = 0; index < count; index++) {\r\n            var sprite = this.sprites[index];\r\n            if (!sprite) {\r\n                continue;\r\n            }\r\n\r\n            if (predicate) {\r\n                if (!predicate(sprite)) {\r\n                    continue;\r\n                }\r\n            } else if (!sprite.isPickable) {\r\n                continue;\r\n            }\r\n\r\n            Vector3.TransformCoordinatesToRef(sprite.position, cameraView, cameraSpacePosition);\r\n\r\n            min.copyFromFloats(cameraSpacePosition.x - sprite.width / 2, cameraSpacePosition.y - sprite.height / 2, cameraSpacePosition.z);\r\n            max.copyFromFloats(cameraSpacePosition.x + sprite.width / 2, cameraSpacePosition.y + sprite.height / 2, cameraSpacePosition.z);\r\n\r\n            if (ray.intersectsBoxMinMax(min, max)) {\r\n                var currentDistance = Vector3.Distance(cameraSpacePosition, ray.origin);\r\n\r\n                if (distance > currentDistance) {\r\n                    distance = currentDistance;\r\n                    currentSprite = sprite;\r\n\r\n                    if (fastCheck) {\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        if (currentSprite) {\r\n            var result = new PickingInfo();\r\n\r\n            cameraView.invertToRef(TmpVectors.Matrix[0]);\r\n            result.hit = true;\r\n            result.pickedSprite = currentSprite;\r\n            result.distance = distance;\r\n\r\n            // Get picked point\r\n            let direction = TmpVectors.Vector3[2];\r\n            direction.copyFrom(ray.direction);\r\n            direction.normalize();\r\n            direction.scaleInPlace(distance);\r\n\r\n            ray.origin.addToRef(direction, pickedPoint);\r\n            result.pickedPoint = Vector3.TransformCoordinates(pickedPoint, TmpVectors.Matrix[0]);\r\n\r\n            return result;\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Intersects the sprites with a ray\r\n     * @param ray defines the ray to intersect with\r\n     * @param camera defines the current active camera\r\n     * @param predicate defines a predicate used to select candidate sprites\r\n     * @returns null if no hit or a PickingInfo array\r\n     */\r\n    public multiIntersects(ray: Ray, camera: Camera, predicate?: (sprite: Sprite) => boolean): Nullable<PickingInfo[]> {\r\n        var count = Math.min(this._capacity, this.sprites.length);\r\n        var min = Vector3.Zero();\r\n        var max = Vector3.Zero();\r\n        var distance: number;\r\n        var results: Nullable<PickingInfo[]> = [];\r\n        var pickedPoint = TmpVectors.Vector3[0].copyFromFloats(0, 0, 0);\r\n        var cameraSpacePosition = TmpVectors.Vector3[1].copyFromFloats(0, 0, 0);\r\n        var cameraView = camera.getViewMatrix();\r\n\r\n        for (var index = 0; index < count; index++) {\r\n            var sprite = this.sprites[index];\r\n            if (!sprite) {\r\n                continue;\r\n            }\r\n\r\n            if (predicate) {\r\n                if (!predicate(sprite)) {\r\n                    continue;\r\n                }\r\n            } else if (!sprite.isPickable) {\r\n                continue;\r\n            }\r\n\r\n            Vector3.TransformCoordinatesToRef(sprite.position, cameraView, cameraSpacePosition);\r\n\r\n            min.copyFromFloats(cameraSpacePosition.x - sprite.width / 2, cameraSpacePosition.y - sprite.height / 2, cameraSpacePosition.z);\r\n            max.copyFromFloats(cameraSpacePosition.x + sprite.width / 2, cameraSpacePosition.y + sprite.height / 2, cameraSpacePosition.z);\r\n\r\n            if (ray.intersectsBoxMinMax(min, max)) {\r\n                distance = Vector3.Distance(cameraSpacePosition, ray.origin);\r\n\r\n                var result = new PickingInfo();\r\n                results.push(result);\r\n\r\n                cameraView.invertToRef(TmpVectors.Matrix[0]);\r\n                result.hit = true;\r\n                result.pickedSprite = sprite;\r\n                result.distance = distance;\r\n\r\n                // Get picked point\r\n                let direction = TmpVectors.Vector3[2];\r\n                direction.copyFrom(ray.direction);\r\n                direction.normalize();\r\n                direction.scaleInPlace(distance);\r\n\r\n                ray.origin.addToRef(direction, pickedPoint);\r\n                result.pickedPoint = Vector3.TransformCoordinates(pickedPoint, TmpVectors.Matrix[0]);\r\n            }\r\n\r\n        }\r\n\r\n        return results;\r\n    }\r\n\r\n    /**\r\n     * Render all child sprites\r\n     */\r\n    public render(): void {\r\n        // Check\r\n        if (!this._effectBase.isReady() || !this._effectFog.isReady() || !this._spriteTexture\r\n            || !this._spriteTexture.isReady() || !this.sprites.length) {\r\n            return;\r\n        }\r\n\r\n        if (this._fromPacked  && (!this._packedAndReady || !this._spriteMap || !this._cellData)) {\r\n            return;\r\n        }\r\n\r\n        var engine = this._scene.getEngine();\r\n        var baseSize = this._spriteTexture.getBaseSize();\r\n\r\n        // Sprites\r\n        var deltaTime = engine.getDeltaTime();\r\n        var max = Math.min(this._capacity, this.sprites.length);\r\n\r\n        var offset = 0;\r\n        let noSprite = true;\r\n        for (var index = 0; index < max; index++) {\r\n            var sprite = this.sprites[index];\r\n            if (!sprite || !sprite.isVisible) {\r\n                continue;\r\n            }\r\n\r\n            noSprite = false;\r\n            sprite._animate(deltaTime);\r\n\r\n            this._appendSpriteVertex(offset++, sprite, 0, 0, baseSize);\r\n            this._appendSpriteVertex(offset++, sprite, 1, 0, baseSize);\r\n            this._appendSpriteVertex(offset++, sprite, 1, 1, baseSize);\r\n            this._appendSpriteVertex(offset++, sprite, 0, 1, baseSize);\r\n        }\r\n\r\n        if (noSprite) {\r\n            return;\r\n        }\r\n\r\n        this._buffer.update(this._vertexData);\r\n\r\n        // Render\r\n        var effect = this._effectBase;\r\n\r\n        if (this._scene.fogEnabled && this._scene.fogMode !== Scene.FOGMODE_NONE && this.fogEnabled) {\r\n            effect = this._effectFog;\r\n        }\r\n\r\n        engine.enableEffect(effect);\r\n\r\n        var viewMatrix = this._scene.getViewMatrix();\r\n        effect.setTexture(\"diffuseSampler\", this._spriteTexture);\r\n        effect.setMatrix(\"view\", viewMatrix);\r\n        effect.setMatrix(\"projection\", this._scene.getProjectionMatrix());\r\n\r\n        // Fog\r\n        if (this._scene.fogEnabled && this._scene.fogMode !== Scene.FOGMODE_NONE && this.fogEnabled) {\r\n            effect.setFloat4(\"vFogInfos\", this._scene.fogMode, this._scene.fogStart, this._scene.fogEnd, this._scene.fogDensity);\r\n            effect.setColor3(\"vFogColor\", this._scene.fogColor);\r\n        }\r\n\r\n        // VBOs\r\n        engine.bindBuffers(this._vertexBuffers, this._indexBuffer, effect);\r\n\r\n        // Draw order\r\n        engine.setDepthFunctionToLessOrEqual();\r\n        if (!this.disableDepthWrite) {\r\n            effect.setBool(\"alphaTest\", true);\r\n            engine.setColorWrite(false);\r\n            engine.drawElementsType(Material.TriangleFillMode, 0, (offset / 4) * 6);\r\n            engine.setColorWrite(true);\r\n            effect.setBool(\"alphaTest\", false);\r\n        }\r\n\r\n        engine.setAlphaMode(this._blendMode);\r\n        engine.drawElementsType(Material.TriangleFillMode, 0, (offset / 4) * 6);\r\n        engine.setAlphaMode(0);\r\n    }\r\n\r\n    /**\r\n     * Release associated resources\r\n     */\r\n    public dispose(): void {\r\n        if (this._buffer) {\r\n            this._buffer.dispose();\r\n            (<any>this._buffer) = null;\r\n        }\r\n\r\n        if (this._indexBuffer) {\r\n            this._scene.getEngine()._releaseBuffer(this._indexBuffer);\r\n            (<any>this._indexBuffer) = null;\r\n        }\r\n\r\n        if (this._spriteTexture) {\r\n            this._spriteTexture.dispose();\r\n            (<any>this._spriteTexture) = null;\r\n        }\r\n\r\n        // Remove from scene\r\n        var index = this._scene.spriteManagers.indexOf(this);\r\n        this._scene.spriteManagers.splice(index, 1);\r\n\r\n        // Callback\r\n        this.onDisposeObservable.notifyObservers(this);\r\n        this.onDisposeObservable.clear();\r\n    }\r\n}"]}