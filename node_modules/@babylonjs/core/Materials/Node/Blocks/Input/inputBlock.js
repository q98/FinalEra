import { __extends } from "tslib";
import { NodeMaterialBlock } from '../../nodeMaterialBlock';
import { NodeMaterialBlockConnectionPointTypes } from '../../Enums/nodeMaterialBlockConnectionPointTypes';
import { NodeMaterialBlockConnectionPointMode } from '../../Enums/nodeMaterialBlockConnectionPointMode';
import { NodeMaterialSystemValues } from '../../Enums/nodeMaterialSystemValues';
import { Matrix, Vector2, Vector3, Vector4 } from '../../../../Maths/math.vector';
import { NodeMaterialBlockTargets } from '../../Enums/nodeMaterialBlockTargets';
import { _TypeStore } from '../../../../Misc/typeStore';
import { Color3, Color4 } from '../../../../Maths/math';
import { AnimatedInputBlockTypes } from './animatedInputBlockTypes';
import { Observable } from '../../../../Misc/observable';
/**
 * Block used to expose an input value
 */
var InputBlock = /** @class */ (function (_super) {
    __extends(InputBlock, _super);
    /**
     * Creates a new InputBlock
     * @param name defines the block name
     * @param target defines the target of that block (Vertex by default)
     * @param type defines the type of the input (can be set to NodeMaterialBlockConnectionPointTypes.AutoDetect)
     */
    function InputBlock(name, target, type) {
        if (target === void 0) { target = NodeMaterialBlockTargets.Vertex; }
        if (type === void 0) { type = NodeMaterialBlockConnectionPointTypes.AutoDetect; }
        var _this = _super.call(this, name, target, false, true) || this;
        _this._mode = NodeMaterialBlockConnectionPointMode.Undefined;
        _this._animationType = AnimatedInputBlockTypes.None;
        /** Gets or set a value used to limit the range of float values */
        _this.min = 0;
        /** Gets or set a value used to limit the range of float values */
        _this.max = 0;
        /** Gets or set a value indicating that this input can only get 0 and 1 values */
        _this.isBoolean = false;
        /** Gets or sets a value used by the Node Material editor to determine how to configure the current value if it is a matrix */
        _this.matrixMode = 0;
        /** @hidden */
        _this._systemValue = null;
        /** Gets or sets a boolean indicating that this input can be edited in the Inspector (false by default) */
        _this.visibleInInspector = false;
        /** Gets or sets a boolean indicating that the value of this input will not change after a build */
        _this.isConstant = false;
        /** Gets or sets the group to use to display this block in the Inspector */
        _this.groupInInspector = "";
        /** Gets an observable raised when the value is changed */
        _this.onValueChangedObservable = new Observable();
        _this._type = type;
        _this.setDefaultValue();
        _this.registerOutput("output", type);
        return _this;
    }
    Object.defineProperty(InputBlock.prototype, "type", {
        /**
         * Gets or sets the connection point type (default is float)
         */
        get: function () {
            if (this._type === NodeMaterialBlockConnectionPointTypes.AutoDetect) {
                if (this.isUniform && this.value != null) {
                    if (!isNaN(this.value)) {
                        this._type = NodeMaterialBlockConnectionPointTypes.Float;
                        return this._type;
                    }
                    switch (this.value.getClassName()) {
                        case "Vector2":
                            this._type = NodeMaterialBlockConnectionPointTypes.Vector2;
                            return this._type;
                        case "Vector3":
                            this._type = NodeMaterialBlockConnectionPointTypes.Vector3;
                            return this._type;
                        case "Vector4":
                            this._type = NodeMaterialBlockConnectionPointTypes.Vector4;
                            return this._type;
                        case "Color3":
                            this._type = NodeMaterialBlockConnectionPointTypes.Color3;
                            return this._type;
                        case "Color4":
                            this._type = NodeMaterialBlockConnectionPointTypes.Color4;
                            return this._type;
                        case "Matrix":
                            this._type = NodeMaterialBlockConnectionPointTypes.Matrix;
                            return this._type;
                    }
                }
                if (this.isAttribute) {
                    switch (this.name) {
                        case "position":
                        case "normal":
                        case "tangent":
                            this._type = NodeMaterialBlockConnectionPointTypes.Vector3;
                            return this._type;
                        case "uv":
                        case "uv2":
                            this._type = NodeMaterialBlockConnectionPointTypes.Vector2;
                            return this._type;
                        case "matricesIndices":
                        case "matricesWeights":
                        case "world0":
                        case "world1":
                        case "world2":
                        case "world3":
                            this._type = NodeMaterialBlockConnectionPointTypes.Vector4;
                            return this._type;
                        case "color":
                            this._type = NodeMaterialBlockConnectionPointTypes.Color4;
                            return this._type;
                    }
                }
                if (this.isSystemValue) {
                    switch (this._systemValue) {
                        case NodeMaterialSystemValues.World:
                        case NodeMaterialSystemValues.WorldView:
                        case NodeMaterialSystemValues.WorldViewProjection:
                        case NodeMaterialSystemValues.View:
                        case NodeMaterialSystemValues.ViewProjection:
                        case NodeMaterialSystemValues.Projection:
                            this._type = NodeMaterialBlockConnectionPointTypes.Matrix;
                            return this._type;
                        case NodeMaterialSystemValues.CameraPosition:
                            this._type = NodeMaterialBlockConnectionPointTypes.Vector3;
                            return this._type;
                        case NodeMaterialSystemValues.FogColor:
                            this._type = NodeMaterialBlockConnectionPointTypes.Color3;
                            return this._type;
                        case NodeMaterialSystemValues.DeltaTime:
                            this._type = NodeMaterialBlockConnectionPointTypes.Float;
                            return this._type;
                    }
                }
            }
            return this._type;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(InputBlock.prototype, "output", {
        /**
         * Gets the output component
         */
        get: function () {
            return this._outputs[0];
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Set the source of this connection point to a vertex attribute
     * @param attributeName defines the attribute name (position, uv, normal, etc...). If not specified it will take the connection point name
     * @returns the current connection point
     */
    InputBlock.prototype.setAsAttribute = function (attributeName) {
        if (attributeName) {
            this.name = attributeName;
        }
        this._mode = NodeMaterialBlockConnectionPointMode.Attribute;
        return this;
    };
    /**
     * Set the source of this connection point to a system value
     * @param value define the system value to use (world, view, etc...) or null to switch to manual value
     * @returns the current connection point
     */
    InputBlock.prototype.setAsSystemValue = function (value) {
        this.systemValue = value;
        return this;
    };
    Object.defineProperty(InputBlock.prototype, "value", {
        /**
         * Gets or sets the value of that point.
         * Please note that this value will be ignored if valueCallback is defined
         */
        get: function () {
            return this._storedValue;
        },
        set: function (value) {
            if (this.type === NodeMaterialBlockConnectionPointTypes.Float) {
                if (this.isBoolean) {
                    value = value ? 1 : 0;
                }
                else if (this.min !== this.max) {
                    value = Math.max(this.min, value);
                    value = Math.min(this.max, value);
                }
            }
            this._storedValue = value;
            this._mode = NodeMaterialBlockConnectionPointMode.Uniform;
            this.onValueChangedObservable.notifyObservers(this);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(InputBlock.prototype, "valueCallback", {
        /**
         * Gets or sets a callback used to get the value of that point.
         * Please note that setting this value will force the connection point to ignore the value property
         */
        get: function () {
            return this._valueCallback;
        },
        set: function (value) {
            this._valueCallback = value;
            this._mode = NodeMaterialBlockConnectionPointMode.Uniform;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(InputBlock.prototype, "associatedVariableName", {
        /**
         * Gets or sets the associated variable name in the shader
         */
        get: function () {
            return this._associatedVariableName;
        },
        set: function (value) {
            this._associatedVariableName = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(InputBlock.prototype, "animationType", {
        /** Gets or sets the type of animation applied to the input */
        get: function () {
            return this._animationType;
        },
        set: function (value) {
            this._animationType = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(InputBlock.prototype, "isUndefined", {
        /**
         * Gets a boolean indicating that this connection point not defined yet
         */
        get: function () {
            return this._mode === NodeMaterialBlockConnectionPointMode.Undefined;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(InputBlock.prototype, "isUniform", {
        /**
         * Gets or sets a boolean indicating that this connection point is coming from an uniform.
         * In this case the connection point name must be the name of the uniform to use.
         * Can only be set on inputs
         */
        get: function () {
            return this._mode === NodeMaterialBlockConnectionPointMode.Uniform;
        },
        set: function (value) {
            this._mode = value ? NodeMaterialBlockConnectionPointMode.Uniform : NodeMaterialBlockConnectionPointMode.Undefined;
            this.associatedVariableName = "";
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(InputBlock.prototype, "isAttribute", {
        /**
         * Gets or sets a boolean indicating that this connection point is coming from an attribute.
         * In this case the connection point name must be the name of the attribute to use
         * Can only be set on inputs
         */
        get: function () {
            return this._mode === NodeMaterialBlockConnectionPointMode.Attribute;
        },
        set: function (value) {
            this._mode = value ? NodeMaterialBlockConnectionPointMode.Attribute : NodeMaterialBlockConnectionPointMode.Undefined;
            this.associatedVariableName = "";
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(InputBlock.prototype, "isVarying", {
        /**
         * Gets or sets a boolean indicating that this connection point is generating a varying variable.
         * Can only be set on exit points
         */
        get: function () {
            return this._mode === NodeMaterialBlockConnectionPointMode.Varying;
        },
        set: function (value) {
            this._mode = value ? NodeMaterialBlockConnectionPointMode.Varying : NodeMaterialBlockConnectionPointMode.Undefined;
            this.associatedVariableName = "";
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(InputBlock.prototype, "isSystemValue", {
        /**
         * Gets a boolean indicating that the current connection point is a system value
         */
        get: function () {
            return this._systemValue != null;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(InputBlock.prototype, "systemValue", {
        /**
         * Gets or sets the current well known value or null if not defined as a system value
         */
        get: function () {
            return this._systemValue;
        },
        set: function (value) {
            this._mode = NodeMaterialBlockConnectionPointMode.Uniform;
            this.associatedVariableName = "";
            this._systemValue = value;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Gets the current class name
     * @returns the class name
     */
    InputBlock.prototype.getClassName = function () {
        return "InputBlock";
    };
    /**
     * Animate the input if animationType !== None
     * @param scene defines the rendering scene
     */
    InputBlock.prototype.animate = function (scene) {
        switch (this._animationType) {
            case AnimatedInputBlockTypes.Time: {
                if (this.type === NodeMaterialBlockConnectionPointTypes.Float) {
                    this.value += scene.getAnimationRatio() * 0.01;
                }
                break;
            }
        }
    };
    InputBlock.prototype._emitDefine = function (define) {
        if (define[0] === "!") {
            return "#ifndef " + define.substring(1) + "\r\n";
        }
        return "#ifdef " + define + "\r\n";
    };
    InputBlock.prototype.initialize = function (state) {
        this.associatedVariableName = "";
    };
    /**
     * Set the input block to its default value (based on its type)
     */
    InputBlock.prototype.setDefaultValue = function () {
        switch (this.type) {
            case NodeMaterialBlockConnectionPointTypes.Float:
                this.value = 0;
                break;
            case NodeMaterialBlockConnectionPointTypes.Vector2:
                this.value = Vector2.Zero();
                break;
            case NodeMaterialBlockConnectionPointTypes.Vector3:
                this.value = Vector3.Zero();
                break;
            case NodeMaterialBlockConnectionPointTypes.Vector4:
                this.value = Vector4.Zero();
                break;
            case NodeMaterialBlockConnectionPointTypes.Color3:
                this.value = Color3.White();
                break;
            case NodeMaterialBlockConnectionPointTypes.Color4:
                this.value = new Color4(1, 1, 1, 1);
                break;
            case NodeMaterialBlockConnectionPointTypes.Matrix:
                this.value = Matrix.Identity();
                break;
        }
    };
    InputBlock.prototype._emitConstant = function (state) {
        switch (this.type) {
            case NodeMaterialBlockConnectionPointTypes.Float:
                return "" + state._emitFloat(this.value);
            case NodeMaterialBlockConnectionPointTypes.Vector2:
                return "vec2(" + this.value.x + ", " + this.value.y + ")";
            case NodeMaterialBlockConnectionPointTypes.Vector3:
                return "vec3(" + this.value.x + ", " + this.value.y + ", " + this.value.z + ")";
            case NodeMaterialBlockConnectionPointTypes.Vector4:
                return "vec4(" + this.value.x + ", " + this.value.y + ", " + this.value.z + ", " + this.value.w + ")";
            case NodeMaterialBlockConnectionPointTypes.Color3:
                return "vec3(" + this.value.r + ", " + this.value.g + ", " + this.value.b + ")";
            case NodeMaterialBlockConnectionPointTypes.Color4:
                return "vec4(" + this.value.r + ", " + this.value.g + ", " + this.value.b + ", " + this.value.a + ")";
        }
        return "";
    };
    InputBlock.prototype._emit = function (state, define) {
        // Uniforms
        if (this.isUniform) {
            if (!this.associatedVariableName) {
                this.associatedVariableName = state._getFreeVariableName("u_" + this.name);
            }
            if (this.isConstant) {
                if (state.constants.indexOf(this.associatedVariableName) !== -1) {
                    return;
                }
                state.constants.push(this.associatedVariableName);
                state._constantDeclaration += this._declareOutput(this.output, state) + (" = " + this._emitConstant(state) + ";\r\n");
                return;
            }
            if (state.uniforms.indexOf(this.associatedVariableName) !== -1) {
                return;
            }
            state.uniforms.push(this.associatedVariableName);
            if (define) {
                state._uniformDeclaration += this._emitDefine(define);
            }
            state._uniformDeclaration += "uniform " + state._getGLType(this.type) + " " + this.associatedVariableName + ";\r\n";
            if (define) {
                state._uniformDeclaration += "#endif\r\n";
            }
            // well known
            var hints = state.sharedData.hints;
            if (this._systemValue !== null && this._systemValue !== undefined) {
                switch (this._systemValue) {
                    case NodeMaterialSystemValues.WorldView:
                        hints.needWorldViewMatrix = true;
                        break;
                    case NodeMaterialSystemValues.WorldViewProjection:
                        hints.needWorldViewProjectionMatrix = true;
                        break;
                }
            }
            else {
                if (this._animationType !== AnimatedInputBlockTypes.None) {
                    state.sharedData.animatedInputs.push(this);
                }
            }
            return;
        }
        // Attribute
        if (this.isAttribute) {
            this.associatedVariableName = this.name;
            if (this.target === NodeMaterialBlockTargets.Vertex && state._vertexState) { // Attribute for fragment need to be carried over by varyings
                this._emit(state._vertexState, define);
                return;
            }
            if (state.attributes.indexOf(this.associatedVariableName) !== -1) {
                return;
            }
            state.attributes.push(this.associatedVariableName);
            if (define) {
                state._attributeDeclaration += this._emitDefine(define);
            }
            state._attributeDeclaration += "attribute " + state._getGLType(this.type) + " " + this.associatedVariableName + ";\r\n";
            if (define) {
                state._attributeDeclaration += "#endif\r\n";
            }
        }
    };
    /** @hidden */
    InputBlock.prototype._transmitWorld = function (effect, world, worldView, worldViewProjection) {
        if (!this._systemValue) {
            return;
        }
        var variableName = this.associatedVariableName;
        switch (this._systemValue) {
            case NodeMaterialSystemValues.World:
                effect.setMatrix(variableName, world);
                break;
            case NodeMaterialSystemValues.WorldView:
                effect.setMatrix(variableName, worldView);
                break;
            case NodeMaterialSystemValues.WorldViewProjection:
                effect.setMatrix(variableName, worldViewProjection);
                break;
        }
    };
    /** @hidden */
    InputBlock.prototype._transmit = function (effect, scene) {
        if (this.isAttribute) {
            return;
        }
        var variableName = this.associatedVariableName;
        if (this._systemValue) {
            switch (this._systemValue) {
                case NodeMaterialSystemValues.World:
                case NodeMaterialSystemValues.WorldView:
                case NodeMaterialSystemValues.WorldViewProjection:
                    return;
                case NodeMaterialSystemValues.View:
                    effect.setMatrix(variableName, scene.getViewMatrix());
                    break;
                case NodeMaterialSystemValues.Projection:
                    effect.setMatrix(variableName, scene.getProjectionMatrix());
                    break;
                case NodeMaterialSystemValues.ViewProjection:
                    effect.setMatrix(variableName, scene.getTransformMatrix());
                    break;
                case NodeMaterialSystemValues.CameraPosition:
                    effect.setVector3(variableName, scene.activeCamera.globalPosition);
                    break;
                case NodeMaterialSystemValues.FogColor:
                    effect.setColor3(variableName, scene.fogColor);
                    break;
                case NodeMaterialSystemValues.DeltaTime:
                    effect.setFloat(variableName, scene.deltaTime / 1000.0);
            }
            return;
        }
        var value = this._valueCallback ? this._valueCallback() : this._storedValue;
        if (value === null) {
            return;
        }
        switch (this.type) {
            case NodeMaterialBlockConnectionPointTypes.Float:
                effect.setFloat(variableName, value);
                break;
            case NodeMaterialBlockConnectionPointTypes.Int:
                effect.setInt(variableName, value);
                break;
            case NodeMaterialBlockConnectionPointTypes.Color3:
                effect.setColor3(variableName, value);
                break;
            case NodeMaterialBlockConnectionPointTypes.Color4:
                effect.setDirectColor4(variableName, value);
                break;
            case NodeMaterialBlockConnectionPointTypes.Vector2:
                effect.setVector2(variableName, value);
                break;
            case NodeMaterialBlockConnectionPointTypes.Vector3:
                effect.setVector3(variableName, value);
                break;
            case NodeMaterialBlockConnectionPointTypes.Vector4:
                effect.setVector4(variableName, value);
                break;
            case NodeMaterialBlockConnectionPointTypes.Matrix:
                effect.setMatrix(variableName, value);
                break;
        }
    };
    InputBlock.prototype._buildBlock = function (state) {
        _super.prototype._buildBlock.call(this, state);
        if (this.isUniform || this.isSystemValue) {
            state.sharedData.inputBlocks.push(this);
        }
        this._emit(state);
    };
    InputBlock.prototype._dumpPropertiesCode = function () {
        var variableName = this._codeVariableName;
        if (this.isAttribute) {
            return variableName + ".setAsAttribute(\"" + this.name + "\");\r\n";
        }
        if (this.isSystemValue) {
            return variableName + ".setAsSystemValue(BABYLON.NodeMaterialSystemValues." + NodeMaterialSystemValues[this._systemValue] + ");\r\n";
        }
        if (this.isUniform) {
            var valueString = "";
            switch (this.type) {
                case NodeMaterialBlockConnectionPointTypes.Float:
                    var returnValue = variableName + ".value = " + this.value + ";\r\n";
                    returnValue += variableName + ".min = " + this.min + ";\r\n";
                    returnValue += variableName + ".max = " + this.max + ";\r\n";
                    returnValue += variableName + ".isBoolean = " + this.isBoolean + ";\r\n";
                    returnValue += variableName + ".matrixMode = " + this.matrixMode + ";\r\n";
                    returnValue += variableName + ".animationType  = BABYLON.AnimatedInputBlockTypes." + AnimatedInputBlockTypes[this.animationType] + ";\r\n";
                    return returnValue;
                case NodeMaterialBlockConnectionPointTypes.Vector2:
                    valueString = "new BABYLON.Vector2(" + this.value.x + ", " + this.value.y + ")";
                    break;
                case NodeMaterialBlockConnectionPointTypes.Vector3:
                    valueString = "new BABYLON.Vector3(" + this.value.x + ", " + this.value.y + ", " + this.value.z + ")";
                    break;
                case NodeMaterialBlockConnectionPointTypes.Vector4:
                    valueString = "new BABYLON.Vector4(" + this.value.x + ", " + this.value.y + ", " + this.value.z + ", " + this.value.w + ")";
                    break;
                case NodeMaterialBlockConnectionPointTypes.Color3:
                    valueString = "new BABYLON.Color3(" + this.value.r + ", " + this.value.g + ", " + this.value.b + ")";
                    break;
                case NodeMaterialBlockConnectionPointTypes.Color4:
                    valueString = "new BABYLON.Color4(" + this.value.r + ", " + this.value.g + ", " + this.value.b + ", " + this.value.a + ")";
                    break;
                case NodeMaterialBlockConnectionPointTypes.Matrix:
                    valueString = "BABYLON.Matrix.FromArray([" + this.value.m.toString() + "])";
                    break;
            }
            var finalOutput = variableName + ".value = " + valueString + ";\r\n";
            finalOutput += variableName + ".isConstant = " + (this.isConstant ? "true" : "false") + ";\r\n";
            finalOutput += variableName + ".visibleInInspector = " + (this.visibleInInspector ? "true" : "false") + ";\r\n";
            return finalOutput;
        }
        return "";
    };
    InputBlock.prototype.dispose = function () {
        this.onValueChangedObservable.clear();
        _super.prototype.dispose.call(this);
    };
    InputBlock.prototype.serialize = function () {
        var serializationObject = _super.prototype.serialize.call(this);
        serializationObject.type = this.type;
        serializationObject.mode = this._mode;
        serializationObject.systemValue = this._systemValue;
        serializationObject.animationType = this._animationType;
        serializationObject.visibleInInspector = this.visibleInInspector;
        serializationObject.min = this.min;
        serializationObject.max = this.max;
        serializationObject.isBoolean = this.isBoolean;
        serializationObject.matrixMode = this.matrixMode;
        serializationObject.isConstant = this.isConstant;
        serializationObject.groupInInspector = this.groupInInspector;
        if (this._storedValue != null && this._mode === NodeMaterialBlockConnectionPointMode.Uniform) {
            if (this._storedValue.asArray) {
                serializationObject.valueType = "BABYLON." + this._storedValue.getClassName();
                serializationObject.value = this._storedValue.asArray();
            }
            else {
                serializationObject.valueType = "number";
                serializationObject.value = this._storedValue;
            }
        }
        return serializationObject;
    };
    InputBlock.prototype._deserialize = function (serializationObject, scene, rootUrl) {
        _super.prototype._deserialize.call(this, serializationObject, scene, rootUrl);
        this._type = serializationObject.type;
        this._mode = serializationObject.mode;
        this._systemValue = serializationObject.systemValue || serializationObject.wellKnownValue;
        this._animationType = serializationObject.animationType;
        this.visibleInInspector = serializationObject.visibleInInspector;
        this.min = serializationObject.min || 0;
        this.max = serializationObject.max || 0;
        this.isBoolean = !!serializationObject.isBoolean;
        this.matrixMode = serializationObject.matrixMode || 0;
        this.isConstant = !!serializationObject.isConstant;
        this.groupInInspector = serializationObject.groupInInspector || "";
        if (!serializationObject.valueType) {
            return;
        }
        if (serializationObject.valueType === "number") {
            this._storedValue = serializationObject.value;
        }
        else {
            var valueType = _TypeStore.GetClass(serializationObject.valueType);
            if (valueType) {
                this._storedValue = valueType.FromArray(serializationObject.value);
            }
        }
    };
    return InputBlock;
}(NodeMaterialBlock));
export { InputBlock };
_TypeStore.RegisteredTypes["BABYLON.InputBlock"] = InputBlock;
//# sourceMappingURL=inputBlock.js.map