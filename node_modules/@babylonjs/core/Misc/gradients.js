import { Color4 } from '../Maths/math.color';
/** Class used to store color4 gradient */
var ColorGradient = /** @class */ (function () {
    function ColorGradient() {
    }
    /**
     * Will get a color picked randomly between color1 and color2.
     * If color2 is undefined then color1 will be used
     * @param result defines the target Color4 to store the result in
     */
    ColorGradient.prototype.getColorToRef = function (result) {
        if (!this.color2) {
            result.copyFrom(this.color1);
            return;
        }
        Color4.LerpToRef(this.color1, this.color2, Math.random(), result);
    };
    return ColorGradient;
}());
export { ColorGradient };
/** Class used to store color 3 gradient */
var Color3Gradient = /** @class */ (function () {
    function Color3Gradient() {
    }
    return Color3Gradient;
}());
export { Color3Gradient };
/** Class used to store factor gradient */
var FactorGradient = /** @class */ (function () {
    function FactorGradient() {
    }
    /**
     * Will get a number picked randomly between factor1 and factor2.
     * If factor2 is undefined then factor1 will be used
     * @returns the picked number
     */
    FactorGradient.prototype.getFactor = function () {
        if (this.factor2 === undefined) {
            return this.factor1;
        }
        return this.factor1 + ((this.factor2 - this.factor1) * Math.random());
    };
    return FactorGradient;
}());
export { FactorGradient };
/**
 * Helper used to simplify some generic gradient tasks
 */
var GradientHelper = /** @class */ (function () {
    function GradientHelper() {
    }
    /**
     * Gets the current gradient from an array of IValueGradient
     * @param ratio defines the current ratio to get
     * @param gradients defines the array of IValueGradient
     * @param updateFunc defines the callback function used to get the final value from the selected gradients
     */
    GradientHelper.GetCurrentGradient = function (ratio, gradients, updateFunc) {
        for (var gradientIndex = 0; gradientIndex < gradients.length - 1; gradientIndex++) {
            var currentGradient = gradients[gradientIndex];
            var nextGradient = gradients[gradientIndex + 1];
            if (ratio >= currentGradient.gradient && ratio <= nextGradient.gradient) {
                var scale = (ratio - currentGradient.gradient) / (nextGradient.gradient - currentGradient.gradient);
                updateFunc(currentGradient, nextGradient, scale);
                return;
            }
        }
        // Use last index if over
        var lastIndex = gradients.length - 1;
        updateFunc(gradients[lastIndex], gradients[lastIndex], 1.0);
    };
    return GradientHelper;
}());
export { GradientHelper };
//# sourceMappingURL=gradients.js.map