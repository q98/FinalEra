{"version":3,"file":"WebXRAnchorSystem.js","sourceRoot":"","sources":["../../../../sourceES6/core/XR/features/WebXRAnchorSystem.ts"],"names":[],"mappings":";AAAA,OAAO,EAAE,gBAAgB,EAAE,MAAM,yBAAyB,CAAC;AAE3D,OAAO,EAAE,UAAU,EAAE,MAAM,uBAAuB,CAAC;AACnD,OAAO,EAAE,MAAM,EAAE,MAAM,yBAAyB,CAAC;AAGjD,OAAO,EAAE,kBAAkB,EAAE,MAAM,sBAAsB,CAAC;AAC1D,OAAO,EAAE,oBAAoB,EAAE,MAAM,wBAAwB,CAAC;AAuC9D,IAAI,gBAAgB,GAAG,CAAC,CAAC;AAEzB;;;;;GAKG;AACH;IAAuC,qCAAoB;IAuDvD;;;;OAIG;IACH,2BAAY,iBAAsC,EAAU,QAAwC;QAAxC,yBAAA,EAAA,aAAwC;QAApG,YACI,kBAAM,iBAAiB,CAAC,SAC3B;QAF2D,cAAQ,GAAR,QAAQ,CAAgC;QA3D5F,cAAQ,GAAY,KAAK,CAAC;QAE1B,wBAAkB,GAAgB,IAAI,GAAG,EAAE,CAAC;QAC5C,eAAS,GAAG,UAAC,KAAyB;YAC1C,IAAI,CAAC,KAAI,CAAC,QAAQ,CAAC,iBAAiB,EAAE;gBAClC,OAAO;aACV;YACD,IAAM,SAAS,GAAG,UAAC,OAAsB;gBACrC,IAAI,OAAO,CAAC,MAAM,EAAE;oBAChB,IAAM,SAAS,GAAG,OAAO,CAAC,CAAC,CAAC,CAAC;oBAC7B,IAAM,SAAS,GAAG,IAAI,gBAAgB,CAAC,SAAS,CAAC,SAAS,CAAC,CAAC;oBAC5D,kCAAkC;oBAClC,KAAI,CAAC,8BAA8B,CAAC,SAAS,CAAC,CAAC;iBAClD;YACL,CAAC,CAAC;YAEF,wDAAwD;YACxD,IAAI,KAAI,CAAC,cAAc,IAAI,CAAC,KAAI,CAAC,cAAc,CAAC,OAAO,CAAC,qBAAqB,EAAE;gBAC3E,SAAS,CAAC,KAAI,CAAC,cAAc,CAAC,sBAAsB,CAAC,CAAC;aACzD;YACD,kBAAkB,CAAC,wBAAwB,CAAC,KAAK,EAAE,KAAI,CAAC,iBAAiB,CAAC,cAAc,CAAC,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC;YAE1G,mDAAmD;YACnD,KAAI,CAAC,cAAc,CAAC;QACxB,CAAC,CAAA;QAGO,qBAAe,GAAwB,EAAE,CAAC;QAalD;;WAEG;QACI,6BAAuB,GAA6B,IAAI,UAAU,EAAE,CAAC;QAC5E;;WAEG;QACI,+BAAyB,GAA6B,IAAI,UAAU,EAAE,CAAC;QAC9E;;;WAGG;QACI,+BAAyB,GAA6B,IAAI,UAAU,EAAE,CAAC;;IAS9E,CAAC;IAED;;;;;;OAMG;IACI,0DAA8B,GAArC,UAAsC,qBAAuC,EAAE,aAA+B;QAC1G,IAAM,OAAO,GAAG,aAAa,IAAI,IAAI,CAAC,iBAAiB,CAAC,OAAO,CAAC;QAChE,OAAO,OAAO,CAAC,YAAY,CAAC,qBAAqB,EAAE,IAAI,CAAC,iBAAiB,CAAC,cAAc,CAAC,CAAC;IAC9F,CAAC;IAED;;;;;OAKG;IACI,kCAAM,GAAb;QACI,IAAI,CAAC,iBAAM,MAAM,WAAE,EAAE;YACjB,OAAO,KAAK,CAAC;SAChB;QACD,IAAI,IAAI,CAAC,QAAQ,CAAC,iBAAiB,EAAE;YACjC,IAAI,CAAC,iBAAiB,CAAC,OAAO,CAAC,gBAAgB,CAAC,QAAQ,EAAE,IAAI,CAAC,SAAS,EAAE,KAAK,CAAC,CAAC;SACpF;QACD,OAAO,IAAI,CAAC;IAChB,CAAC;IAED;;;;;OAKG;IACI,kCAAM,GAAb;QACI,IAAI,CAAC,iBAAM,MAAM,WAAE,EAAE;YACjB,OAAO,KAAK,CAAC;SAChB;QAED,IAAI,CAAC,iBAAiB,CAAC,OAAO,CAAC,mBAAmB,CAAC,QAAQ,EAAE,IAAI,CAAC,SAAS,CAAC,CAAC;QAE7E,OAAO,IAAI,CAAC;IAChB,CAAC;IAED;;OAEG;IACI,mCAAO,GAAd;QACI,iBAAM,OAAO,WAAE,CAAC;QAChB,IAAI,CAAC,uBAAuB,CAAC,KAAK,EAAE,CAAC;QACrC,IAAI,CAAC,yBAAyB,CAAC,KAAK,EAAE,CAAC;QACvC,IAAI,CAAC,yBAAyB,CAAC,KAAK,EAAE,CAAC;IAC3C,CAAC;IAED;;;OAGG;IACI,4CAAgB,GAAvB,UAAwB,aAAiC;QACrD,IAAI,CAAC,cAAc,GAAG,aAAa,CAAC;IACxC,CAAC;IAED;;;;OAIG;IACI,4CAAgB,GAAvB,UAAwB,aAAiC,EAAE,MAAsB;QAAtB,uBAAA,EAAA,aAAsB;QAC7E,IAAI,CAAC,cAAc,GAAG,aAAa,CAAC;QACpC,IAAI,CAAC,QAAQ,CAAC,iBAAiB,GAAG,MAAM,CAAC;IAC7C,CAAC;IAES,sCAAU,GAApB,UAAqB,KAAc;QAAnC,iBAgCC;QA/BG,IAAI,CAAC,IAAI,CAAC,QAAQ,IAAI,CAAC,IAAI,CAAC,QAAQ,IAAI,CAAC,KAAK,EAAE;YAAE,OAAO;SAAE;QAE3D,IAAM,cAAc,GAAG,KAAK,CAAC,cAAc,CAAC;QAC5C,IAAI,cAAc,IAAI,cAAc,CAAC,IAAI,EAAE;YACvC,IAAI,CAAC,eAAe,CAAC,MAAM,CAAC,UAAC,MAAM,IAAK,OAAA,CAAC,cAAc,CAAC,GAAG,CAAC,MAAM,CAAC,QAAQ,CAAC,EAApC,CAAoC,CAAC,CAAC,GAAG,CAAC,UAAC,MAAM;gBACrF,IAAM,KAAK,GAAG,KAAI,CAAC,eAAe,CAAC,OAAO,CAAC,MAAM,CAAC,CAAC;gBACnD,KAAI,CAAC,eAAe,CAAC,MAAM,CAAC,KAAK,EAAE,CAAC,CAAC,CAAC;gBACtC,KAAI,CAAC,yBAAyB,CAAC,eAAe,CAAC,MAAM,CAAC,CAAC;YAC3D,CAAC,CAAC,CAAC;YACH,yBAAyB;YACzB,cAAc,CAAC,OAAO,CAAC,UAAC,QAAQ;gBAC5B,IAAI,CAAC,KAAI,CAAC,kBAAkB,CAAC,GAAG,CAAC,QAAQ,CAAC,EAAE;oBACxC,IAAM,SAAS,GAA0B;wBACrC,EAAE,EAAE,gBAAgB,EAAE;wBACtB,QAAQ,EAAE,QAAQ;qBACrB,CAAC;oBACF,IAAM,KAAK,GAAG,KAAI,CAAC,wBAAwB,CAAC,QAAQ,EAAE,SAAS,EAAE,KAAK,CAAC,CAAC;oBACxE,KAAI,CAAC,eAAe,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;oBACjC,KAAI,CAAC,uBAAuB,CAAC,eAAe,CAAC,KAAK,CAAC,CAAC;iBACvD;qBAAM;oBACH,WAAW;oBACX,IAAI,QAAQ,CAAC,eAAe,KAAK,KAAI,CAAC,iBAAiB,CAAC,gBAAgB,EAAE;wBACtE,IAAI,KAAK,GAAG,KAAI,CAAC,uBAAuB,CAAC,QAAQ,CAAC,CAAC;wBACnD,IAAM,MAAM,GAAG,KAAI,CAAC,eAAe,CAAC,KAAK,CAAC,CAAC;wBAC3C,KAAI,CAAC,wBAAwB,CAAC,QAAQ,EAAE,MAAM,EAAE,KAAK,CAAC,CAAC;wBACvD,KAAI,CAAC,yBAAyB,CAAC,eAAe,CAAC,MAAM,CAAC,CAAC;qBAC1D;iBACJ;YACL,CAAC,CAAC,CAAC;YACH,IAAI,CAAC,kBAAkB,GAAG,cAAc,CAAC;SAC5C;IACL,CAAC;IAED;;;OAGG;IACK,mDAAuB,GAA/B,UAAgC,QAAkB;QAC9C,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,IAAI,CAAC,eAAe,CAAC,MAAM,EAAE,EAAE,CAAC,EAAE;YAClD,IAAI,IAAI,CAAC,eAAe,CAAC,CAAC,CAAC,CAAC,QAAQ,KAAK,QAAQ,EAAE;gBAC/C,OAAO,CAAC,CAAC;aACZ;SACJ;QACD,OAAO,CAAC,CAAC,CAAC;IACd,CAAC;IAEO,oDAAwB,GAAhC,UAAiC,QAAkB,EAAE,MAA6B,EAAE,OAAgB;QAChG,SAAS;QACT,IAAM,IAAI,GAAG,OAAO,CAAC,OAAO,CAAC,QAAQ,CAAC,WAAW,EAAE,IAAI,CAAC,iBAAiB,CAAC,cAAc,CAAC,CAAC;QAC1F,IAAI,IAAI,EAAE;YACN,IAAM,GAAG,GAAG,MAAM,CAAC,oBAAoB,IAAI,IAAI,MAAM,EAAE,CAAC;YACxD,MAAM,CAAC,cAAc,CAAC,IAAI,CAAC,SAAS,CAAC,MAAM,EAAE,CAAC,EAAE,GAAG,CAAC,CAAC;YACrD,IAAI,CAAC,IAAI,CAAC,iBAAiB,CAAC,KAAK,CAAC,oBAAoB,EAAE;gBACpD,GAAG,CAAC,4BAA4B,EAAE,CAAC;aACtC;YACD,MAAM,CAAC,oBAAoB,GAAG,GAAG,CAAC;YAClC,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,eAAe,EAAE;gBAChC,mFAAmF;aACtF;iBAAM;gBACH,GAAG,CAAC,aAAa,CAAC,IAAI,CAAC,QAAQ,CAAC,eAAe,CAAC,cAAc,EAAE,EAAE,GAAG,CAAC,CAAC;aAC1E;SACJ;QAED,OAAqB,MAAM,CAAC;IAChC,CAAC;IA3KD;;OAEG;IACoB,sBAAI,GAAG,gBAAgB,CAAC,aAAa,CAAC;IAC7D;;;;OAIG;IACoB,yBAAO,GAAG,CAAC,CAAC;IAmKvC,wBAAC;CAAA,AA1MD,CAAuC,oBAAoB,GA0M1D;SA1MY,iBAAiB;AA4M9B,sBAAsB;AACtB,gGAAgG;AAChG,qEAAqE;AACrE,iCAAiC","sourcesContent":["import { WebXRFeatureName } from '../webXRFeaturesManager';\r\nimport { WebXRSessionManager } from '../webXRSessionManager';\r\nimport { Observable } from '../../Misc/observable';\r\nimport { Matrix } from '../../Maths/math.vector';\r\nimport { TransformNode } from '../../Meshes/transformNode';\r\nimport { WebXRPlaneDetector } from './WebXRPlaneDetector';\r\nimport { WebXRHitTestLegacy } from './WebXRHitTestLegacy';\r\nimport { WebXRAbstractFeature } from './WebXRAbstractFeature';\r\n\r\n/**\r\n * Configuration options of the anchor system\r\n */\r\nexport interface IWebXRAnchorSystemOptions {\r\n    /**\r\n     * Should a new anchor be added every time a select event is triggered\r\n     */\r\n    addAnchorOnSelect?: boolean;\r\n    /**\r\n     * should the anchor system use plane detection.\r\n     * If set to true, the plane-detection feature should be set using setPlaneDetector\r\n     */\r\n    usePlaneDetection?: boolean;\r\n    /**\r\n     * a node that will be used to convert local to world coordinates\r\n     */\r\n    worldParentNode?: TransformNode;\r\n}\r\n\r\n/**\r\n * A babylon container for an XR Anchor\r\n */\r\nexport interface IWebXRAnchor {\r\n    /**\r\n     * A babylon-assigned ID for this anchor\r\n     */\r\n    id: number;\r\n    /**\r\n     * Transformation matrix to apply to an object attached to this anchor\r\n     */\r\n    transformationMatrix: Matrix;\r\n    /**\r\n     * The native anchor object\r\n     */\r\n    xrAnchor: XRAnchor;\r\n}\r\n\r\nlet anchorIdProvider = 0;\r\n\r\n/**\r\n * An implementation of the anchor system of WebXR.\r\n * Note that the current documented implementation is not available in any browser. Future implementations\r\n * will use the frame to create an anchor and not the session or a detected plane\r\n * For further information see https://github.com/immersive-web/anchors/\r\n */\r\nexport class WebXRAnchorSystem extends WebXRAbstractFeature {\r\n    private _enabled: boolean = false;\r\n    private _hitTestModule: WebXRHitTestLegacy;\r\n    private _lastFrameDetected: XRAnchorSet = new Set();\r\n    private _onSelect = (event: XRInputSourceEvent) => {\r\n        if (!this._options.addAnchorOnSelect) {\r\n            return;\r\n        }\r\n        const onResults = (results: XRHitResult[]) => {\r\n            if (results.length) {\r\n                const hitResult = results[0];\r\n                const transform = new XRRigidTransform(hitResult.hitMatrix);\r\n                // find the plane on which to add.\r\n                this.addAnchorAtRigidTransformation(transform);\r\n            }\r\n        };\r\n\r\n        // avoid the hit-test, if the hit-test module is defined\r\n        if (this._hitTestModule && !this._hitTestModule.options.testOnPointerDownOnly) {\r\n            onResults(this._hitTestModule.lastNativeXRHitResults);\r\n        }\r\n        WebXRHitTestLegacy.XRHitTestWithSelectEvent(event, this._xrSessionManager.referenceSpace).then(onResults);\r\n\r\n        // API will soon change, will need to use the plane\r\n        this._planeDetector;\r\n    }\r\n\r\n    private _planeDetector: WebXRPlaneDetector;\r\n    private _trackedAnchors: Array<IWebXRAnchor> = [];\r\n\r\n    /**\r\n     * The module's name\r\n     */\r\n    public static readonly Name = WebXRFeatureName.ANCHOR_SYSTEM;\r\n    /**\r\n     * The (Babylon) version of this module.\r\n     * This is an integer representing the implementation version.\r\n     * This number does not correspond to the WebXR specs version\r\n     */\r\n    public static readonly Version = 1;\r\n\r\n    /**\r\n     * Observers registered here will be executed when a new anchor was added to the session\r\n     */\r\n    public onAnchorAddedObservable: Observable<IWebXRAnchor> = new Observable();\r\n    /**\r\n     * Observers registered here will be executed when an anchor was removed from the session\r\n     */\r\n    public onAnchorRemovedObservable: Observable<IWebXRAnchor> = new Observable();\r\n    /**\r\n     * Observers registered here will be executed when an existing anchor updates\r\n     * This can execute N times every frame\r\n     */\r\n    public onAnchorUpdatedObservable: Observable<IWebXRAnchor> = new Observable();\r\n\r\n    /**\r\n     * constructs a new anchor system\r\n     * @param _xrSessionManager an instance of WebXRSessionManager\r\n     * @param _options configuration object for this feature\r\n     */\r\n    constructor(_xrSessionManager: WebXRSessionManager, private _options: IWebXRAnchorSystemOptions = {}) {\r\n        super(_xrSessionManager);\r\n    }\r\n\r\n    /**\r\n     * Add anchor at a specific XR point.\r\n     *\r\n     * @param xrRigidTransformation xr-coordinates where a new anchor should be added\r\n     * @param anchorCreator the object o use to create an anchor with. either a session or a plane\r\n     * @returns a promise the fulfills when the anchor was created\r\n     */\r\n    public addAnchorAtRigidTransformation(xrRigidTransformation: XRRigidTransform, anchorCreator?: XRAnchorCreator): Promise<XRAnchor> {\r\n        const creator = anchorCreator || this._xrSessionManager.session;\r\n        return creator.createAnchor(xrRigidTransformation, this._xrSessionManager.referenceSpace);\r\n    }\r\n\r\n    /**\r\n     * attach this feature\r\n     * Will usually be called by the features manager\r\n     *\r\n     * @returns true if successful.\r\n     */\r\n    public attach(): boolean {\r\n        if (!super.attach()) {\r\n            return false;\r\n        }\r\n        if (this._options.addAnchorOnSelect) {\r\n            this._xrSessionManager.session.addEventListener('select', this._onSelect, false);\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * detach this feature.\r\n     * Will usually be called by the features manager\r\n     *\r\n     * @returns true if successful.\r\n     */\r\n    public detach(): boolean {\r\n        if (!super.detach()) {\r\n            return false;\r\n        }\r\n\r\n        this._xrSessionManager.session.removeEventListener('select', this._onSelect);\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Dispose this feature and all of the resources attached\r\n     */\r\n    public dispose(): void {\r\n        super.dispose();\r\n        this.onAnchorAddedObservable.clear();\r\n        this.onAnchorRemovedObservable.clear();\r\n        this.onAnchorUpdatedObservable.clear();\r\n    }\r\n\r\n    /**\r\n     * If set, it will improve performance by using the current hit-test results instead of executing a new hit-test\r\n     * @param hitTestModule the hit-test module to use.\r\n     */\r\n    public setHitTestModule(hitTestModule: WebXRHitTestLegacy) {\r\n        this._hitTestModule = hitTestModule;\r\n    }\r\n\r\n    /**\r\n     * set the plane detector to use in order to create anchors from frames\r\n     * @param planeDetector the plane-detector module to use\r\n     * @param enable enable plane-anchors. default is true\r\n     */\r\n    public setPlaneDetector(planeDetector: WebXRPlaneDetector, enable: boolean = true) {\r\n        this._planeDetector = planeDetector;\r\n        this._options.usePlaneDetection = enable;\r\n    }\r\n\r\n    protected _onXRFrame(frame: XRFrame) {\r\n        if (!this.attached || !this._enabled || !frame) { return; }\r\n\r\n        const trackedAnchors = frame.trackedAnchors;\r\n        if (trackedAnchors && trackedAnchors.size) {\r\n            this._trackedAnchors.filter((anchor) => !trackedAnchors.has(anchor.xrAnchor)).map((anchor) => {\r\n                const index = this._trackedAnchors.indexOf(anchor);\r\n                this._trackedAnchors.splice(index, 1);\r\n                this.onAnchorRemovedObservable.notifyObservers(anchor);\r\n            });\r\n            // now check for new ones\r\n            trackedAnchors.forEach((xrAnchor) => {\r\n                if (!this._lastFrameDetected.has(xrAnchor)) {\r\n                    const newAnchor: Partial<IWebXRAnchor> = {\r\n                        id: anchorIdProvider++,\r\n                        xrAnchor: xrAnchor\r\n                    };\r\n                    const plane = this._updateAnchorWithXRFrame(xrAnchor, newAnchor, frame);\r\n                    this._trackedAnchors.push(plane);\r\n                    this.onAnchorAddedObservable.notifyObservers(plane);\r\n                } else {\r\n                    // updated?\r\n                    if (xrAnchor.lastChangedTime === this._xrSessionManager.currentTimestamp) {\r\n                        let index = this._findIndexInAnchorArray(xrAnchor);\r\n                        const anchor = this._trackedAnchors[index];\r\n                        this._updateAnchorWithXRFrame(xrAnchor, anchor, frame);\r\n                        this.onAnchorUpdatedObservable.notifyObservers(anchor);\r\n                    }\r\n                }\r\n            });\r\n            this._lastFrameDetected = trackedAnchors;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * avoiding using Array.find for global support.\r\n     * @param xrAnchor the plane to find in the array\r\n     */\r\n    private _findIndexInAnchorArray(xrAnchor: XRAnchor) {\r\n        for (let i = 0; i < this._trackedAnchors.length; ++i) {\r\n            if (this._trackedAnchors[i].xrAnchor === xrAnchor) {\r\n                return i;\r\n            }\r\n        }\r\n        return -1;\r\n    }\r\n\r\n    private _updateAnchorWithXRFrame(xrAnchor: XRAnchor, anchor: Partial<IWebXRAnchor>, xrFrame: XRFrame): IWebXRAnchor {\r\n        // matrix\r\n        const pose = xrFrame.getPose(xrAnchor.anchorSpace, this._xrSessionManager.referenceSpace);\r\n        if (pose) {\r\n            const mat = anchor.transformationMatrix || new Matrix();\r\n            Matrix.FromArrayToRef(pose.transform.matrix, 0, mat);\r\n            if (!this._xrSessionManager.scene.useRightHandedSystem) {\r\n                mat.toggleModelMatrixHandInPlace();\r\n            }\r\n            anchor.transformationMatrix = mat;\r\n            if (!this._options.worldParentNode) {\r\n                // Logger.Warn(\"Please provide a world parent node to apply world transformation\");\r\n            } else {\r\n                mat.multiplyToRef(this._options.worldParentNode.getWorldMatrix(), mat);\r\n            }\r\n        }\r\n\r\n        return <IWebXRAnchor>anchor;\r\n    }\r\n}\r\n\r\n// register the plugin\r\n// WebXRFeaturesManager.AddWebXRFeature(WebXRAnchorSystem.Name, (xrSessionManager, options) => {\r\n//     return () => new WebXRAnchorSystem(xrSessionManager, options);\r\n// }, WebXRAnchorSystem.Version);"]}