import { __extends } from "tslib";
import { WebXRFeatureName } from '../webXRFeaturesManager';
import { Observable } from '../../Misc/observable';
import { Matrix } from '../../Maths/math.vector';
import { WebXRHitTestLegacy } from './WebXRHitTestLegacy';
import { WebXRAbstractFeature } from './WebXRAbstractFeature';
var anchorIdProvider = 0;
/**
 * An implementation of the anchor system of WebXR.
 * Note that the current documented implementation is not available in any browser. Future implementations
 * will use the frame to create an anchor and not the session or a detected plane
 * For further information see https://github.com/immersive-web/anchors/
 */
var WebXRAnchorSystem = /** @class */ (function (_super) {
    __extends(WebXRAnchorSystem, _super);
    /**
     * constructs a new anchor system
     * @param _xrSessionManager an instance of WebXRSessionManager
     * @param _options configuration object for this feature
     */
    function WebXRAnchorSystem(_xrSessionManager, _options) {
        if (_options === void 0) { _options = {}; }
        var _this = _super.call(this, _xrSessionManager) || this;
        _this._options = _options;
        _this._enabled = false;
        _this._lastFrameDetected = new Set();
        _this._onSelect = function (event) {
            if (!_this._options.addAnchorOnSelect) {
                return;
            }
            var onResults = function (results) {
                if (results.length) {
                    var hitResult = results[0];
                    var transform = new XRRigidTransform(hitResult.hitMatrix);
                    // find the plane on which to add.
                    _this.addAnchorAtRigidTransformation(transform);
                }
            };
            // avoid the hit-test, if the hit-test module is defined
            if (_this._hitTestModule && !_this._hitTestModule.options.testOnPointerDownOnly) {
                onResults(_this._hitTestModule.lastNativeXRHitResults);
            }
            WebXRHitTestLegacy.XRHitTestWithSelectEvent(event, _this._xrSessionManager.referenceSpace).then(onResults);
            // API will soon change, will need to use the plane
            _this._planeDetector;
        };
        _this._trackedAnchors = [];
        /**
         * Observers registered here will be executed when a new anchor was added to the session
         */
        _this.onAnchorAddedObservable = new Observable();
        /**
         * Observers registered here will be executed when an anchor was removed from the session
         */
        _this.onAnchorRemovedObservable = new Observable();
        /**
         * Observers registered here will be executed when an existing anchor updates
         * This can execute N times every frame
         */
        _this.onAnchorUpdatedObservable = new Observable();
        return _this;
    }
    /**
     * Add anchor at a specific XR point.
     *
     * @param xrRigidTransformation xr-coordinates where a new anchor should be added
     * @param anchorCreator the object o use to create an anchor with. either a session or a plane
     * @returns a promise the fulfills when the anchor was created
     */
    WebXRAnchorSystem.prototype.addAnchorAtRigidTransformation = function (xrRigidTransformation, anchorCreator) {
        var creator = anchorCreator || this._xrSessionManager.session;
        return creator.createAnchor(xrRigidTransformation, this._xrSessionManager.referenceSpace);
    };
    /**
     * attach this feature
     * Will usually be called by the features manager
     *
     * @returns true if successful.
     */
    WebXRAnchorSystem.prototype.attach = function () {
        if (!_super.prototype.attach.call(this)) {
            return false;
        }
        if (this._options.addAnchorOnSelect) {
            this._xrSessionManager.session.addEventListener('select', this._onSelect, false);
        }
        return true;
    };
    /**
     * detach this feature.
     * Will usually be called by the features manager
     *
     * @returns true if successful.
     */
    WebXRAnchorSystem.prototype.detach = function () {
        if (!_super.prototype.detach.call(this)) {
            return false;
        }
        this._xrSessionManager.session.removeEventListener('select', this._onSelect);
        return true;
    };
    /**
     * Dispose this feature and all of the resources attached
     */
    WebXRAnchorSystem.prototype.dispose = function () {
        _super.prototype.dispose.call(this);
        this.onAnchorAddedObservable.clear();
        this.onAnchorRemovedObservable.clear();
        this.onAnchorUpdatedObservable.clear();
    };
    /**
     * If set, it will improve performance by using the current hit-test results instead of executing a new hit-test
     * @param hitTestModule the hit-test module to use.
     */
    WebXRAnchorSystem.prototype.setHitTestModule = function (hitTestModule) {
        this._hitTestModule = hitTestModule;
    };
    /**
     * set the plane detector to use in order to create anchors from frames
     * @param planeDetector the plane-detector module to use
     * @param enable enable plane-anchors. default is true
     */
    WebXRAnchorSystem.prototype.setPlaneDetector = function (planeDetector, enable) {
        if (enable === void 0) { enable = true; }
        this._planeDetector = planeDetector;
        this._options.usePlaneDetection = enable;
    };
    WebXRAnchorSystem.prototype._onXRFrame = function (frame) {
        var _this = this;
        if (!this.attached || !this._enabled || !frame) {
            return;
        }
        var trackedAnchors = frame.trackedAnchors;
        if (trackedAnchors && trackedAnchors.size) {
            this._trackedAnchors.filter(function (anchor) { return !trackedAnchors.has(anchor.xrAnchor); }).map(function (anchor) {
                var index = _this._trackedAnchors.indexOf(anchor);
                _this._trackedAnchors.splice(index, 1);
                _this.onAnchorRemovedObservable.notifyObservers(anchor);
            });
            // now check for new ones
            trackedAnchors.forEach(function (xrAnchor) {
                if (!_this._lastFrameDetected.has(xrAnchor)) {
                    var newAnchor = {
                        id: anchorIdProvider++,
                        xrAnchor: xrAnchor
                    };
                    var plane = _this._updateAnchorWithXRFrame(xrAnchor, newAnchor, frame);
                    _this._trackedAnchors.push(plane);
                    _this.onAnchorAddedObservable.notifyObservers(plane);
                }
                else {
                    // updated?
                    if (xrAnchor.lastChangedTime === _this._xrSessionManager.currentTimestamp) {
                        var index = _this._findIndexInAnchorArray(xrAnchor);
                        var anchor = _this._trackedAnchors[index];
                        _this._updateAnchorWithXRFrame(xrAnchor, anchor, frame);
                        _this.onAnchorUpdatedObservable.notifyObservers(anchor);
                    }
                }
            });
            this._lastFrameDetected = trackedAnchors;
        }
    };
    /**
     * avoiding using Array.find for global support.
     * @param xrAnchor the plane to find in the array
     */
    WebXRAnchorSystem.prototype._findIndexInAnchorArray = function (xrAnchor) {
        for (var i = 0; i < this._trackedAnchors.length; ++i) {
            if (this._trackedAnchors[i].xrAnchor === xrAnchor) {
                return i;
            }
        }
        return -1;
    };
    WebXRAnchorSystem.prototype._updateAnchorWithXRFrame = function (xrAnchor, anchor, xrFrame) {
        // matrix
        var pose = xrFrame.getPose(xrAnchor.anchorSpace, this._xrSessionManager.referenceSpace);
        if (pose) {
            var mat = anchor.transformationMatrix || new Matrix();
            Matrix.FromArrayToRef(pose.transform.matrix, 0, mat);
            if (!this._xrSessionManager.scene.useRightHandedSystem) {
                mat.toggleModelMatrixHandInPlace();
            }
            anchor.transformationMatrix = mat;
            if (!this._options.worldParentNode) {
                // Logger.Warn("Please provide a world parent node to apply world transformation");
            }
            else {
                mat.multiplyToRef(this._options.worldParentNode.getWorldMatrix(), mat);
            }
        }
        return anchor;
    };
    /**
     * The module's name
     */
    WebXRAnchorSystem.Name = WebXRFeatureName.ANCHOR_SYSTEM;
    /**
     * The (Babylon) version of this module.
     * This is an integer representing the implementation version.
     * This number does not correspond to the WebXR specs version
     */
    WebXRAnchorSystem.Version = 1;
    return WebXRAnchorSystem;
}(WebXRAbstractFeature));
export { WebXRAnchorSystem };
// register the plugin
// WebXRFeaturesManager.AddWebXRFeature(WebXRAnchorSystem.Name, (xrSessionManager, options) => {
//     return () => new WebXRAnchorSystem(xrSessionManager, options);
// }, WebXRAnchorSystem.Version);
//# sourceMappingURL=WebXRAnchorSystem.js.map