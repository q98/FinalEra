import { Matrix } from "../Maths/math.vector";
import { SubMesh } from "../Meshes/subMesh";
import { Mesh } from "../Meshes/mesh";
import { MultiRenderTarget } from "../Materials/Textures/multiRenderTarget";
import { Effect } from "../Materials/effect";
import { Scene } from "../scene";
import { AbstractMesh } from "../Meshes/abstractMesh";
import "../Shaders/geometry.fragment";
import "../Shaders/geometry.vertex";
/** @hidden */
interface ISavedTransformationMatrix {
    world: Matrix;
    viewProjection: Matrix;
}
/**
 * This renderer is helpfull to fill one of the render target with a geometry buffer.
 */
export declare class GeometryBufferRenderer {
    /**
     * Constant used to retrieve the position texture index in the G-Buffer textures array
     * using getIndex(GeometryBufferRenderer.POSITION_TEXTURE_INDEX)
     */
    static readonly POSITION_TEXTURE_TYPE = 1;
    /**
     * Constant used to retrieve the velocity texture index in the G-Buffer textures array
     * using getIndex(GeometryBufferRenderer.VELOCITY_TEXTURE_INDEX)
     */
    static readonly VELOCITY_TEXTURE_TYPE = 2;
    /**
     * Constant used to retrieve the reflectivity texture index in the G-Buffer textures array
     * using the getIndex(GeometryBufferRenderer.REFLECTIVITY_TEXTURE_TYPE)
     */
    static readonly REFLECTIVITY_TEXTURE_TYPE = 3;
    /**
     * Dictionary used to store the previous transformation matrices of each rendered mesh
     * in order to compute objects velocities when enableVelocity is set to "true"
     * @hidden
     */
    _previousTransformationMatrices: {
        [index: number]: ISavedTransformationMatrix;
    };
    /**
     * Dictionary used to store the previous bones transformation matrices of each rendered mesh
     * in order to compute objects velocities when enableVelocity is set to "true"
     * @hidden
     */
    _previousBonesTransformationMatrices: {
        [index: number]: Float32Array;
    };
    /**
     * Array used to store the ignored skinned meshes while computing velocity map (typically used by the motion blur post-process).
     * Avoids computing bones velocities and computes only mesh's velocity itself (position, rotation, scaling).
     */
    excludedSkinnedMeshesFromVelocity: AbstractMesh[];
    /** Gets or sets a boolean indicating if transparent meshes should be rendered */
    renderTransparentMeshes: boolean;
    private _scene;
    private _multiRenderTarget;
    private _ratio;
    private _enablePosition;
    private _enableVelocity;
    private _enableReflectivity;
    private _positionIndex;
    private _velocityIndex;
    private _reflectivityIndex;
    protected _effect: Effect;
    protected _cachedDefines: string;
    /**
     * Set the render list (meshes to be rendered) used in the G buffer.
     */
    set renderList(meshes: Mesh[]);
    /**
     * Gets wether or not G buffer are supported by the running hardware.
     * This requires draw buffer supports
     */
    get isSupported(): boolean;
    /**
     * Returns the index of the given texture type in the G-Buffer textures array
     * @param textureType The texture type constant. For example GeometryBufferRenderer.POSITION_TEXTURE_INDEX
     * @returns the index of the given texture type in the G-Buffer textures array
     */
    getTextureIndex(textureType: number): number;
    /**
     * Gets a boolean indicating if objects positions are enabled for the G buffer.
     */
    get enablePosition(): boolean;
    /**
     * Sets whether or not objects positions are enabled for the G buffer.
     */
    set enablePosition(enable: boolean);
    /**
     * Gets a boolean indicating if objects velocities are enabled for the G buffer.
     */
    get enableVelocity(): boolean;
    /**
     * Sets wether or not objects velocities are enabled for the G buffer.
     */
    set enableVelocity(enable: boolean);
    /**
     * Gets a boolean indicating if objects roughness are enabled in the G buffer.
     */
    get enableReflectivity(): boolean;
    /**
     * Sets wether or not objects roughness are enabled for the G buffer.
     */
    set enableReflectivity(enable: boolean);
    /**
     * Gets the scene associated with the buffer.
     */
    get scene(): Scene;
    /**
     * Gets the ratio used by the buffer during its creation.
     * How big is the buffer related to the main canvas.
     */
    get ratio(): number;
    /** @hidden */
    static _SceneComponentInitialization: (scene: Scene) => void;
    /**
     * Creates a new G Buffer for the scene
     * @param scene The scene the buffer belongs to
     * @param ratio How big is the buffer related to the main canvas.
     */
    constructor(scene: Scene, ratio?: number);
    /**
     * Checks wether everything is ready to render a submesh to the G buffer.
     * @param subMesh the submesh to check readiness for
     * @param useInstances is the mesh drawn using instance or not
     * @returns true if ready otherwise false
     */
    isReady(subMesh: SubMesh, useInstances: boolean): boolean;
    /**
     * Gets the current underlying G Buffer.
     * @returns the buffer
     */
    getGBuffer(): MultiRenderTarget;
    /**
     * Gets the number of samples used to render the buffer (anti aliasing).
     */
    get samples(): number;
    /**
     * Sets the number of samples used to render the buffer (anti aliasing).
     */
    set samples(value: number);
    /**
     * Disposes the renderer and frees up associated resources.
     */
    dispose(): void;
    protected _createRenderTargets(): void;
    private _copyBonesTransformationMatrices;
}
export {};
